✓ Build a formula-tree generation system
    ✓ Random, but still correct, formulas given a chosen length
    ✓ Modal depth regulation
    ✓ Test (I would like to do more tests)
    ☐ Guarantee the same generation-probability foreach possible formula
    ✓ Think about other parameters to tweak (pruning factor)

✓ Build an appropriate model generation system

☐ Multiple formulas multiple models - model checking
    ✓ Single model checking
    ✓ Different types of values supported by memoization structure 
    (Worlds, thus Vector{AbstractWorld}, and WorldsSet, thus Set{AbstractWorld})
    ✓ Memoization regulation 
    ✓ Put everything togheter (see comments in `check`) #NOTE: experiments.jl
    ✓ Correctness check
    ☐ Find a trick to safely remove _process_node from exports without breaking the tests
    ☐ Parallelize where possible (https://docs.julialang.org/en/v1/manual/multi-threading/)
        "Base collection types require manual locking if used simultaneously by multiple 
        threads where at least one thread modifies the collection 
        (common examples include push! on arrays, or inserting items into a Dict)."
    ✓ Plots
    ✓ Get rid of boring precompilation times as much as possible (https://julialang.org/blog/2021/01/precompile_tutorial/)

✓ Find a way to memoize "a DISJUNCTION b" with the same hash as "b  DISJUNCTION a"; 
    (call a normalization function before model checking, using is_commutative trait)
    ✓ thus, implement some `isless` function 

✓ "formula" parameter in hashing could be removed 
    (just do hash(token(node))).

✓ Maybe L could operate through intersection between sets
    L is the internal memo structure utilized by a Kripke Model. 
    The previous mapping (hashed_subformula, world) -> boolean 
    is now changed in (hashed_subformula) -> some_world_collection (possibly empty)

✓ Make args more manageable
✓ Add rng injection whenever rand() is used in exported functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Todos for the future:

☐ Inject Logic in Node and Formula (SoleLogics)
    ☐ Define a general Logic for manage dispatches where it's not specified 
☐ Write a Relations hierarchy (in SoleLogics) thus extending KripkeModel's `Adjacents`
✓ Write some Letter struct and avoid working with plain strings (SoleAlphabet)
☐ Refine code since now it only works with PointWorlds
☐ Look for more appropriate variable names
☐ Add types when a optional argument is given in a function
? Force "test/plots" folder push to github, since this is randomly ignored also by manually adding it in a new commit.
☐ Consider leaf nodes as sentinels when calling gen_formula
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
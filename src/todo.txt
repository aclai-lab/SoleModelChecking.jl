✓ Build a formula-tree generation system
    ✓ Random, but still correct, formulas given a chosen length
    ✓ Modal depth regulation
    ✓ Test (I would like to do more tests)
    ☐ Guarantee the same generation-probability foreach possible formula
    ☐ Think about other parameters to tweak

✓ Build an appropriate model generation system

☐ Multiple formulas multiple models - model checking
    ✓ Single model checking
    ✓ Different types of values supported by memoization structure 
    (Worlds, thus Vector{AbstractWorld}, and WorldsSet, thus Set{AbstractWorld})
    ✓ Memoization regulation 
    ✓ Put everything togheter (see comments in `check`) #NOTE: experiments.jl
    ✓ Correctness check
    ☐ Find a trick to safely remove _process_node from exports without breaking the tests
    ☐ Parallelize where possible (https://docs.julialang.org/en/v1/manual/multi-threading/)
        "Base collection types require manual locking if used simultaneously by multiple 
        threads where at least one thread modifies the collection 
        (common examples include push! on arrays, or inserting items into a Dict)."
    ✓ Plots
    ☐ Get rid of boring precompilation times as much as possible (https://julialang.org/blog/2021/01/precompile_tutorial/)

✓ Find a way to memoize "a DISJUNCTION b" with the same hash as "b  DISJUNCTION a"; 
    (call a normalization function before model checking, using is_commutative trait)
    ✓ thus, implement some `isless` function 

✓ "formula" parameter in hashing could be removed 
    (just do hash(token(node))).

✓ Maybe L could operate through intersection between sets
    L is the internal memo structure utilized by a Kripke Model. 
    The previous mapping (hashed_subformula, world) -> boolean 
    is now changed in (hashed_subformula) -> some_world_collection (possibly empty)

☐ Make args more manageable
☐ Add rng injection whenever rand() is used in exported functions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Todos for the future:

☐ Write a Relations hierarchy (in SoleLogics) thus extending KripkeModel's `Adjacents`
☐ Write some Letter struct and avoid working with plain strings (SoleAlphabet)
☐ Refine code since now it only works with PointWorlds
☐ Look for more appropriate variable names
☐ Add types when a optional argument is given in a function
☐ Force "test/plots" folder push to github, since this is randomly ignored also by manually adding it in a new commit.
☐ Consider leaf nodes as sentinels when calling gen_formula
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

New dependencies (see Project.toml) to GraphPlotting:
GraphPlot = "a2cc645c-3eea-5389-862e-a155d0052231"
GraphRecipes = "bd48cda9-67a9-57be-86fa-5b3c104eda73"
Graphs = "86223c79-3864-5bf0-83f7-82e725a168b6"
Plots = "91a5bcdd-55d7-5caf-9e0b-520d859cae80"
Compose = "a81c6b42-2e10-5240-aca2-a61377ecd94b"